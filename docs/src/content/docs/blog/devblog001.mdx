---
title: GIIN begins
date: 2025-08-29
slug: 2025-08-29-devblog
featured: true
---
import demoLog1 from '/src/assets/giin-log3.mp4';
import giinLogo from '/src/assets/giin-logo-temp.png';
import sq007b from '/src/assets/sq007b-final.png';
import excelToPsd from '/src/assets/excel-to-ps-proto.png';
import { Image } from 'astro:assets';

<Image src={giinLogo} alt='GIIN logo' />

**Generic Incremental Interactive eNgine (GIIN)** is a game engine for menu-driven games on the web, currently in early development.

It supports basic visual novel mechanics similar to [Twine](www.twinery.org), and is in development towards supporting incremental and adventure game mechanics. It is built on [ReactJS](https://react.dev/) and its primary data-editing interface is [Microsoft Excel](https://en.wikipedia.org/wiki/Microsoft_Excel).

## Beginnings

GIIN began life sometime in July 2025 as a Vite-TypeScript-React template app. The initial goal was to create an engine that could make incremental or visual novel games. These genres felt suitable for a single developer to relearn how to make games. The goal has since expanded to support any menu-driven gameplay.

Here's a a demo showing basic visual novel features:

<video width="480" height="360" controls><source src={demoLog1} type="video/mp4" /></video>
_**Figure**. Choices, branching dialog, and portrait support._

Previously, I'd shipped a few [hidden object + adventure games](https://store.steampowered.com/app/466030/Otherworld_Spring_of_Shadows_Collectors_Edition/) using a proprietary game engine called Sleipnir made by C++ programmers; I was a productive designer on that engine and wanted to recreate the snappiness of making games with it.
 
Sleipnir used MS Excel to manage variables in the game, which made data normalization and bulk updates trivial. While it is obvious today to use some spreadsheet export function to JSON or CSV, back in 2010 using Excel to export to `.lua` data files was new to me. (I'd simply added objects manually to a MySQL database before that.)

After creating variables, the designers then prepare a prototype PSD file with the correct layer names that correrspond to the variables in the Excel file:

<Image src={excelToPsd} alt='Excel and PSD export with matching variable names' />
<Image src={sq007b} alt='Final art of puzzle' />
Click the video to see a streamer play the puzzle:
<iframe
src="https://www.youtube.com/embed/vClmDekSGso?start=761"
frameborder="0"  
allowfullscreen></iframe>

To play to my strengths and to learn new skills, I decided that GIIN would use the following:

- **React and TypeScript** for the frontend and logic: I'd coded in React/TypeScript on and off on the job, but always in bits and pieces I decided it was time for me to learn it.
- An **xlwings** Python exporter from MS Excel for the data export: Previously I'd used xlwings to create prototypes and I was (and am) more comfortable with Excel data validation, macros, and shortcuts.

I have used MS Excel for 6 years to handle large amounts of game data and continue to do so for these reasons:

- It's easy to update content in bulk.
- You can validate data in different ways.
- You can concatenate from other cells to set up paths and other formulaic values. 
- Having data in a tabular format makes it easy to normalize the data.

## The first milestone: a data exporter and editor

My first milestone was to be able to quickly export data from Excel into the game.

Given something like:

tk

A corresponding table in Excel would look like this:

tk

And in the game UI:

tk

## Data export pipeline as proof-of-concept milestone

![No capes meme](/public/memes/no-capes.gif)

_No hardcoded data!_

I wanted a simple **data export pipeline as my first milestone** for the following reasons:

### Pipeline is everything

A good pipeline supported by good tools means that mistakes can be corrected quickly, that data (content) can be easily placed into the game, and people can check their own work.

### It's a proof-of-concept for myself

Making a data exporter is tells me that I have sufficient programming chops, or learning chops, to pull off a simple menu-based game. It's proof that I can make a basic game pipeline from end-to-end.

### It enforces data and logic separation early

Hardcoded data is difficult to find and refactor the longer it stays in the engine.

## The method

I planned to keep the scope for the exporter as small as I could. I asked myself, _what's the smallest unit of gameplay I can express through data?_ Between incremental mechanics and visual novel mechanics, the easier system is the visual novel, so that's what I decided to work on.

A visual novel can be as simple as the player meeting a love interest, talking to them, and increasing the affection level through certain choices. Thus the bare minimum goal was to create:

- A **love interest** with an **affection** stat.
- **Dialog** that ends in a question for the player to interact with.
- A set of **choices** with different **stat effects**, some raising the love interest's affection stat more than others.

To make the whole pipeline, I wrote the code in this order:

1. **The initial game UI (or frontend) in React**. The game at this point used hardcoded, dummy data stored as variables.
2. **The game objects, such as the concept of a love interest, a stat, a choice**. I used object-oriented programming for these. At this stage I wrote some classes, then their instances were imported into the game UI. The instances were still in a sense hardcoded, in that they were still difficult to create or update in bulk.
3. **The exporter in Excel**. 
4. **The game UI, refactored**. I went back to the game UI and removed the hardcoded variables.

The pipeline came to life in that order with some backtracking when I needed to correct some design decisions.

