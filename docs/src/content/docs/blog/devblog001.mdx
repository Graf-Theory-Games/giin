---
title: GIIN begins
date: 2025-08-29
slug: 2025-08-29-devblog
featured: true
---
import demoLog1 from '/src/assets/giin-log3.mp4';
import giinLogo from '/src/assets/giin-logo-temp.png';
import sq007b from '/src/assets/sq007b-final.png';
import excelToPsd from '/src/assets/excel-to-ps-proto.png';
import dv001InterfaceObject from '/src/assets/dv001-interface-object.jpg';
import dv001LoveInterest from '/src/assets/dv001-loveinterest.jpg';
import dv001Choices from '/src/assets/dv001-choices.jpg';
import dv001EvtGroup from '/src/assets/dv001-evtgroup.jpg';
import noCapes from '/src/assets/memes/no-capes.gif';
import dv001Breakdown from '/src/assets/dv001-breakdown.png';
import dv001React from '/src/assets/dv001-react.png';

import { Image } from 'astro:assets';

<Image src={giinLogo} alt='GIIN logo' />

**Generic Incremental Interactive eNgine (GIIN)** is a game engine for menu-driven games on the web, currently in early development.

It supports basic visual novel mechanics similar to [Twine](www.twinery.org), and is in development towards supporting incremental and adventure game mechanics. It is built on [ReactJS](https://react.dev/) and its primary data-editing interface is [Microsoft Excel](https://en.wikipedia.org/wiki/Microsoft_Excel).

## Beginnings

GIIN began life sometime in July 2025 as a Vite-TypeScript-React template app. The initial goal was to create an engine that could make incremental or visual novel games. These genres felt suitable for a single developer to relearn how to make games. The goal has since expanded to support any menu-driven gameplay.

Here's a a demo showing basic visual novel features:

<video width="480" height="360" controls><source src={demoLog1} type="video/mp4" /></video>
_Choices, branching dialog, and portrait support._

## Background

Previously, I'd shipped a few [hidden object + adventure games](https://store.steampowered.com/app/466030/Otherworld_Spring_of_Shadows_Collectors_Edition/) using a proprietary C++ game engine called Sleipnir; I was a productive designer on that engine and wanted to recreate the snappiness of making games with it.
 
Sleipnir used MS Excel to manage variables in the game, which made data normalization and bulk updates trivial. While it is obvious today to use some spreadsheet export function to JSON or CSV, back in 2010 using Excel to export to `.lua` data files was new to me. (I'd simply added objects manually to a MySQL database before that.)

After scripting in variables (events, actors, actions, et cetera) in Excel, the designers then prepared a prototype PSD file with the correct layer names that corresponded to the variables in the Excel file:

<Image src={excelToPsd} alt='Excel and PSD export with matching variable names' />

Then the artist finalized the art, keeping the layer names intact. A dedicated PSD export tool cut up the layers into image files.
<Image src={sq007b} alt='Final art of puzzle' />

Puzzle mechanics and behaviors were also defined through attributes exported from Excel. Watch the video to see a streamer play the puzzle:

<iframe
src="https://www.youtube.com/embed/vClmDekSGso?start=761"
frameborder="0"  
allowfullscreen></iframe>

<br />

> _**I really enjoyed using Excel, but for my own projects, I didn't want to make an exporter using VBA.**_

Fortunately, [xlwings](https://www.xlwings.org/) was already available by the time I felt I was ready to make my own exporter.

To play to my strengths and to learn new skills, I decided that GIIN would use the following:

- **React and TypeScript** for the frontend and logic. 
- An **xlwings** Python exporter from MS Excel for the data export.

I have used MS Excel for 6 years to handle large amounts of game data and continue to do so for these reasons:

- It's easy to update content in bulk.
- You can validate data in different ways.
- You can concatenate values from other cells to set up paths and other formulaic values. 
- Having data in a tabular format makes it easy to normalize the data.
- I was (and am) more comfortable with Excel data validation, macros, and shortcuts.

## The first milestone: a data exporter and editor

My first milestone was to be able to quickly export data from Excel into the game.

Given something like:

<Image src={dv001InterfaceObject} alt='Interface with labeled objects' />

Corresponding tables in Excel would look like this:

<Image src={dv001LoveInterest} alt='Excel tables' />

For the **Love Interest** object, you'd create a new row or entry in the `LoveInterest` sheet, then attach a `stats` array from a separate `stats` sheet. The screenshots provide the following data:

- There is a love interest the user can romance named **HIKER_BOYFIE**.
- **HIKER_BOYFIE** has **hiker_stats** which give him an **affection** of **41** out of a max of **99**.

<Image src={dv001Choices} alt='Excel tables' />

- For the **Choices** array, an **identifier** is used to link the choices together, which tells the engine that the three choices belong to the same array.

Let's stop here for now; a discussion of the data's architecture is a blog post for another day.

## Data export pipeline as proof-of-concept milestone 

<Image src={noCapes} alt='No capes meme' />

_No hardcoded data!_

I wanted a simple **data export pipeline as my first milestone** for the following reasons:

### Pipeline is everything

A good pipeline supported by good tools means that mistakes can be corrected quickly, that data (content) can be easily placed into the game, and people can check their own work.

It boggles my mind that some build pipelines require the artist or designer to **wait** for the programmer to give them a new build after the assets are submitted. No! Content creators, artists and designers, should be able to use the last available build, or a localhost in this case, and put the data and assets themselves, **without a programmer**.

For 6 years of my salaried, professional work as a designer, starting in 2010, my team and I did this, so clearly it's not new technology.

Looking back at old games, both Starcraft and Warcraft 2 had level editors available to burgeoning game designers. Those were some of the earliest game design software available to kids. We sure as hell didn't need a programmer to build a separate exe file for us.

### It's a proof-of-concept for myself

Making a data exporter is tells me that I have sufficient programming chops, or learning chops, to pull off a simple menu-based game. It's proof that I can make a basic game pipeline from end-to-end.

### It enforces data and logic separation early

Hardcoded data is difficult to find and refactor the longer it stays in the engine.

## The method

I planned to keep the scope for the exporter as small as I could. I asked myself, 

> _**What's the smallest unit of gameplay I can express through data?**_ 

Between incremental mechanics and visual novel mechanics, the easier system is the visual novel, so that's what I decided to work on.

<Image src={dv001Breakdown} alt='Breakdown of Love Interest, Affection, Stat Effects, and Choices in a simple interaction' />

A visual novel can be as simple as the player meeting a love interest, talking to them, and increasing the affection level through certain choices. Thus the bare minimum goal was to create:

- A **love interest** with an **affection** stat.
- **Dialog** that ends in a question for the player to interact with.
- A set of **choices** with different **stat effects**, some raising the love interest's affection stat more than others.

To make the whole pipeline, I wrote the code in this order:

1. **The initial game UI (or frontend) in React**. The game at this point used hardcoded, dummy data stored as variables.
2. **The game objects, such as the concept of a love interest, a stat, a choice**. I used object-oriented programming for these. At this stage I wrote some classes, then their instances were imported into the game UI. The instances were still in a sense hardcoded, in that they were still difficult to create or update in bulk.
3. **The exporter in Excel**. 
4. **The game UI, refactored**. I went back to the game UI and removed the hardcoded variables.

<Image src={dv001React} alt='React code and game screen in inset.' />
_Some code remains hardcoded while I build out the features._

The pipeline came to life in that order with some backtracking when I needed to correct some design decisions.

## The result

The result is a simple system that feels dynamic. You can make any number of stats, any number of events, any number of choices, and most importantly, the choices have **consequences** in the form of stat effects. 

Note that you can define stats that **aren't** affection; any stat you want to keep track of, such as hit points, energy, and so on can be scripted in.

Most importantly, the data is easy to place into the game for testing.

## Next steps

- **Features**: My next goal, feature-wise, is to create a player character. I don't have a player character object yet, so the player character doesn't have a score, or energy, or any other stat.
- **Maintenance**: I have to refactor the game screen, written all in React, as I feel my first pass was a little janky.
- **Learning**: I have to study more about React Hooks because at the moment I use several of them without fully understanding them.
- **This devlog**: The next post will be about normalization in game design.

