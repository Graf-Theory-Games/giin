---
title: GIIN begins
date: 2025-08-29
slug: 2025-08-29-devblog
featured: true
---
import demoLog1 from '/src/assets/giin-log3.mp4';
import giinLogo from '/src/assets/giin-logo-temp.png';
import sq007b from '/src/assets/sq007b-final.png';
import excelToPsd from '/src/assets/excel-to-ps-proto.png';
import dv001InterfaceObject from '/src/assets/dv001-interface-object.jpg';
import dv001LoveInterest from '/src/assets/dv001-loveinterest.jpg';
import dv001Choices from '/src/assets/dv001-choices.jpg';
import dv001EvtGroup from '/src/assets/dv001-evtgroup.jpg';
import noCapes from '/src/assets/memes/no-capes.gif';

import { Image } from 'astro:assets';

<Image src={giinLogo} alt='GIIN logo' />

**Generic Incremental Interactive eNgine (GIIN)** is a game engine for menu-driven games on the web, currently in early development.

It supports basic visual novel mechanics similar to [Twine](www.twinery.org), and is in development towards supporting incremental and adventure game mechanics. It is built on [ReactJS](https://react.dev/) and its primary data-editing interface is [Microsoft Excel](https://en.wikipedia.org/wiki/Microsoft_Excel).

## Beginnings

GIIN began life sometime in July 2025 as a Vite-TypeScript-React template app. The initial goal was to create an engine that could make incremental or visual novel games. These genres felt suitable for a single developer to relearn how to make games. The goal has since expanded to support any menu-driven gameplay.

Here's a a demo showing basic visual novel features:

<video width="480" height="360" controls><source src={demoLog1} type="video/mp4" /></video>
_**Figure**. Choices, branching dialog, and portrait support._

## Background

Previously, I'd shipped a few [hidden object + adventure games](https://store.steampowered.com/app/466030/Otherworld_Spring_of_Shadows_Collectors_Edition/) using a proprietary C++ game engine called Sleipnir; I was a productive designer on that engine and wanted to recreate the snappiness of making games with it.
 
Sleipnir used MS Excel to manage variables in the game, which made data normalization and bulk updates trivial. While it is obvious today to use some spreadsheet export function to JSON or CSV, back in 2010 using Excel to export to `.lua` data files was new to me. (I'd simply added objects manually to a MySQL database before that.)

After scripting in variables (events, actors, actions, et cetera) in Excel, the designers then prepared a prototype PSD file with the correct layer names that corresponded to the variables in the Excel file:

<Image src={excelToPsd} alt='Excel and PSD export with matching variable names' />

Then the artist finalized the art, keeping the layer names intact. A dedicated PSD export tool would cut up the layers into image files.
<Image src={sq007b} alt='Final art of puzzle' />

Puzzle mechanics and behaviors were also defined through attributes exported from Excel. See the video to see a streamer play the puzzle:

<iframe
src="https://www.youtube.com/embed/vClmDekSGso?start=761"
frameborder="0"  
allowfullscreen></iframe>

<br />

> _**I really enjoyed using Excel, but I didn't want to make an exporter using VBA.**_

Fortunately, xlwings was already available by the time I felt I was ready to make an exporter.

To play to my strengths and to learn new skills, I decided that GIIN would use the following:

- **React and TypeScript** for the frontend and logic.
- An **xlwings** Python exporter from MS Excel for the data export.

I have used MS Excel for 6 years to handle large amounts of game data and continue to do so for these reasons:

- It's easy to update content in bulk.
- You can validate data in different ways.
- You can concatenate from other cells to set up paths and other formulaic values. 
- Having data in a tabular format makes it easy to normalize the data.
- I was (and am) more comfortable with Excel data validation, macros, and shortcuts.

## The first milestone: a data exporter and editor

My first milestone was to be able to quickly export data from Excel into the game.

Given something like:

<Image src={dv001InterfaceObject} alt='Interface with labeled objects' />

Corresponding tables in Excel would look like this:

<Image src={dv001LoveInterest} alt='Excel tables' />

For the **Love Interest** object, you'd create a new row or entry in the `LoveInterest` sheet, then attach a `stats` array from a separate `stats` sheet. The screenshots provide the following data:

- There is a love interest the user can romance named **HIKER_BOYFIE**.
- **HIKER_BOYFIE** has **hiker_stats** which give him an **affection** of **41** out of a max of **99**.

<Image src={dv001Choices} alt='Excel tables' />

- For the **Choices** array, an **identifier** is used to link the choices together, which tells the engine that the three choices belong to the same array.
- The identifier value, **hiker1** corresponds to an object called the **evtGroup** (Event Group).
- The **evtGroup** is basically a series of Events or Dialogs that can end in a Choice interaction for the users.

<Image src={dv001EvtGroup} alt='Excel tables' />

- The **EvtGroup** is the basic building block of the game. It defines a sequence of events and dialog that can end in a choice the user has to make, or it can transition to another EvtGroup.
- The `hiker1` value for the headers `evts` and `choices` are **lookup values** that say, "look for the identifier `hiker1` in the corresponding sheets".

## Data export pipeline as proof-of-concept milestone 

<Image src={noCapes} alt='No capes meme' />

_No hardcoded data!_

I wanted a simple **data export pipeline as my first milestone** for the following reasons:

### Pipeline is everything

A good pipeline supported by good tools means that mistakes can be corrected quickly, that data (content) can be easily placed into the game, and people can check their own work.

### It's a proof-of-concept for myself

Making a data exporter is tells me that I have sufficient programming chops, or learning chops, to pull off a simple menu-based game. It's proof that I can make a basic game pipeline from end-to-end.

### It enforces data and logic separation early

Hardcoded data is difficult to find and refactor the longer it stays in the engine.

## The method

I planned to keep the scope for the exporter as small as I could. I asked myself, 

> _**What's the smallest unit of gameplay I can express through data?**_ 

Between incremental mechanics and visual novel mechanics, the easier system is the visual novel, so that's what I decided to work on.

A visual novel can be as simple as the player meeting a love interest, talking to them, and increasing the affection level through certain choices. Thus the bare minimum goal was to create:

- A **love interest** with an **affection** stat.
- **Dialog** that ends in a question for the player to interact with.
- A set of **choices** with different **stat effects**, some raising the love interest's affection stat more than others.

To make the whole pipeline, I wrote the code in this order:

1. **The initial game UI (or frontend) in React**. The game at this point used hardcoded, dummy data stored as variables.
2. **The game objects, such as the concept of a love interest, a stat, a choice**. I used object-oriented programming for these. At this stage I wrote some classes, then their instances were imported into the game UI. The instances were still in a sense hardcoded, in that they were still difficult to create or update in bulk.
3. **The exporter in Excel**. 
4. **The game UI, refactored**. I went back to the game UI and removed the hardcoded variables.

The pipeline came to life in that order with some backtracking when I needed to correct some design decisions.

## The result

tk

## Next steps

tk
