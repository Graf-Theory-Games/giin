---
title: Basic stat setting and normalization in games
date: 2025-10-13
slug: 2025-10-13-devblog
featured: true
---

import playtime from '/src/assets/dv002-playtime.jpg';
import sliders from '/src/assets/dv002-sliders.jpg'
import square from '/src/assets/dv002-square.jpg'
import triace from '/src/assets/dv002-triace.png'
import party from '/src/assets/dv002-6v6.jpg'
import part from '/src/assets/dv002-part-of-whole.jpg'
import part2 from '/src/assets/dv002-part.jpg'
import ff8 from '/src/assets/dv002-ff8.jpg'
import no from '/src/assets/no.gif'
import phyrexian from '/src/assets/dv002-dreadnaught.jpg'
import iseria from '/src/assets/dv002-iseria.png'
import stones from '/src/assets/dv002-sacredstones.png'
import diff from '/src/assets/dv002-diff.jpg'
import wars from '/src/assets/dv002-advancewars.png'

import { Image } from 'astro:assets';

How do we game designers know what values to use for our video games? Some games cap at level 99; others cap at level 20. Some games have 6 primary stats; other games have 8 or 10.

<Image src={square} alt='' width={256} layout='constrained' />

_Square games in the 90s and early 2000s capped out at **255** for each whole number stat and **9999** for HP._

<Image src={triace} alt='' />
_tri-Ace games in the 90s and early 2000s capped out... wherever the hell they wanted to._

## Working forwards or backwards

One method to figure out values for stats is to prototype a core loop of gameplay, **working forward**. You'd start prototyping the this loop, and possibly 2-3 other loops, giving yourself a deadline measured in weeks, not months. Those weeks are spent assembling a prototype with placeholder art and animation cues. In this scenario, you haven't figured out how big the game is going to be, nor how long it will take to get to the end, but you have to start somewhere.

Another method is to **work backwards**, or to begin with the end in mind, i.e. a release window. I've done this with projects where a period of experimentation, about 3 months for a vertical slice of a game, is baked into the costing and is part of a "real" timetable with milestones (deadlines) mapped to distributor and publisher events. **You're not just doing a core loop prototype**. With this method, the team is usually able to figure out the costing for the game and the amount of content based on results during this vertical slice and experimentation phase.

### A short note on working backwards

Knowing the **amount** of content absolutely matters for stat adjustment:

- If you know your team can only make 60 unique creature designs in time for public beta, and you have an evolution mechanism, that works out to 30 monsters (each monster needs a unique "child" and "adult" design) thus the leveling formula has to account for that.
- If you know that your game will have updates on the 1st week, 3rd week, first month, and so on, you might want to adjust stats to accommodate for that. Sometimes you might think to yourself, "Oh, our 999 max stat for a single-release game should be 9999 for a rolling-release game so that users feel like they've progressed more over the year of updates."

By working with a final deadline, we are also able to set a **cutoff line** that keeps scope creep at bay, among other things.

Today however we'll be focusing on the "working forward" approach, which is more friendly towards hobbyists and indies.

## The basics of working forward

Do you know much time it takes for you to make one minute of gameplay? Have you ever tried to time yourself when creating your game content?

<Image src={playtime} alt='' width={480} />

You may want to start conservatively (3 to 5 minute game demo) until you build confidence in your experience. Remember that the tutorials of games can be 3 minutes or less and that a starting Pokemon battle against a Lv. 2 Rattata takes about 4 movesâ€”less than a minute.

1. Figure out your core loop. You can do this by identifying **repeating blocks of gameplay with clear win (progression) conditions**. Your core loop will be among these, but there will be many other important loops.
1. Write the sequence or flow chart of the core loop. What steps will the user do? What states can they wind up in?
1. Compute the number of moves it takes to finish the core loop. Moves can either be **turn-based** or **time-based**. With back-of-the-napkin math, you can establish initial values before the prototype is finished, then feed the values to the prototype.
    - An example of a time-based move is a basic slash of a Paladin from Warcraft. You can expect a Paladin to slash every N seconds.
    - An example of a turn-based move is the Attack option in Suikoden II.
1. Prototype the core loop. 
1. Once the prototype has been finished with reasonable placeholder pauses for animation and cueing, test the values.

This blog post mostly explores **step (3)**.

## Example 1: Choosing a role-playing game's core loop

RPGs have several major systems, including but not limited to:

- Exploration
- Battle
- Crafting

Any one of these could form the core loop of a game.

For the purposes of this blog post, let's take a look at a typical battle loop. The **win condition** of a battle is straightforward: it ends when the enemy party's hit points (HP) hits zero. To finish the core loop, you just have to keep reducing the HP, typically through an attack. So when you prototype the battle, you can start with as little as:

- The characters
- An attack command
- Hit points
- Attack or damage points

<Image src={party} alt='' layout='constrained' />
_3-vs-3, 4-vs-4, and 6-vs-6 party sizes have to be set up in such a way that battle isn't tedious._

### Controlling the size of a gameplay loop

Here are two hopefully uncontroversial statements:

- All other things being equal, a large Starcraft map where the players are situated at opposite ends will take longer to finish than a smaller map.
- All other things being equal, A 6-vs-6 Pokemon battle will take longer than a 3-vs-3.

Let's say we want an RPG **player-versus-player** (PVP) game to be about **3-5 minutes** long.

> _The average completion of an RPG battle can be measured in the **number of moves or turns** made to complete the loop._

Thus we should convert the average number of turns into some time measurement.

Let's say that Player A and Player B use similar characters: 

| Character lineup | Atk | HP |
| -------          | ------ | ------ |
|  Abel            | 5    | 100 |
|  Benjamin        | 9    | 75  |
|  Cain            | 5    | 120 |
|  Daniel          | 7    | 90  |

**Total HP**: 385

**Total Atk**: 26

<Image src={part} alt='' />
_You can already see where this is going..._

Dividing the **total HP** by the **total Atk** gives us an idea of how many turns you'd have to hit the opposite party.

It comes out to 14.81, or **15 turns of solid attacking** to knock out 4 characters. There are 2 players, each taking turns hitting each other. So at a minimum, **29 turns**.

Now we wanted our battle to last 3-5 minutes, or 180-300 seconds. Let's work backwards from those values:

```
180 seconds / 29 turns = 6.21 seconds per turn
300 seconds / 29 turns = 10.34 seconds per turn
```

6-10 seconds per turn is too little time to decide on the actions of 4 characters, so it's obvious that these numbers are unrealistic. The game will definitely drag on to more than 5 minutes, especially once we add other options aside from Attack.

It's evident that the HP is too high or the Atk is too low. Now that we know how to compute for the number of turns, let's **set a limit of 5 turns per player** by reducing the HP.

Let's get the total HP to end a party in 6 turns: 

```
(Total Atk) * (Ideal number of turns) = (New Total HP)
    26      *           5             = 130


(Previous Total HP) - (New Total HP) = (Reduction in HP)
        385         -     130           = 255
```


<Image src={part2} alt='' />
_Now it only takes us... 9 turns to finish a fight._

That comes to a 63.75HP reduction per character.

For now let's apply it evenly across the board, rounding down:

| Character lineup | Atk | HP |
| -------          | ------ | ------ |
|  Abel            | 5    | 37 |
|  Benjamin        | 9    | 12  |
|  Cain            | 5    | 57 |
|  Daniel          | 7    | 27  |

Just from reading those numbers and their variance between characters you can already see that there's more tension (and that Benjamin should probably be rebalanced)â€”and we haven't even touched on other actions, such as Magic, or events such as Miss and Critical.

## Using "big" or "small" numbers

What meaning do numbers have if a game's core loop is measured in percentages? The choice of big (`9,999`, `99,999`) or small (`99`) numbers boils down to utility and emotion.

<Image src={ff8} alt='' />
_To keep battle relevant, enemies scale to the same level as the protagonists in FFVIII regardless of location._

### Bigger isn't always meaningful  

A chessboard has 64 squares, or 2^6. If we increase the chessboard size to 128, or 2^7, we know instinctively that we should scale the movement of knights, pawns, and kings (bishops, queens, and towers can move any number of tiles, so they stay the same).

Some things to ponder:

- If we scale the movement up, does that mean that the game would take more time to finish?
- Would scaling movement retain the utility of the chess piece?

In other words, would scaling up be meaningful?

<Image src={no} alt='' width={256} layout='constrained' />

Let's take a look at the case for small numbers.

#### Small numbers for PVP and prototyping

<Image src={phyrexian} alt='' width={256} layout='constrained' />
_Many card and board games keep their numbers relatively small._

Numbers are kept "small" because players do the math themselves. Baldur's Gate, which mostly follows 5th Edition Dungeons and Dragons (DnD) mechanics, caps out at level 20. The numbers of a standard polyhedral dice set don't go over 99. This is because DnD was originally played on paper and pencil and thus the game's number scale follows suit.

#### Big numbers for expressing game progression, PvE games

Big numbers tug at our emotions. They give users a sense of progression. After all, the hours you spend on a game only go up, so your stats should too. You start with 50 HP and ten hours in it's hit 7,000. That gives you a sense of accomplishment.

Mind you, game designers have the option to lessen the amount of experience points doled out; some RPGs require that you only have 100 EXP to level up for each level. But where's the fun in that?


<Image src={iseria} alt='' />
_The Iseria Queen from Valkyrie Profile is the last secret optional boss of the game and has... 2,300,000 HP._

## Our last topic for today: normalization

Normalization in game design ensures that stats (health, speed, power, etc.) are balanced and meaningful across the board.

### Example 2: Thinking in percentages in a strategy game

Let's look at the ingredients of a turn-based strategy game.

<Image src={stones} alt='' />
_tk add description Fire Emblem: The Sacred Stones_

<Image src={wars} alt='' />
_tk add description Advance Wars 2 UI_

Based off of these images, we can identify the following components:

- A **board** composed of tiles.
- These **tiles** represent **terrain**, and have bonuses or penalties depending on the unit traversing them.
- **Units** the player controls, with movement and strength stats.

So let's set up some stats for a strategy game with two systems, **unit types** and **terrain**:

| Unit types   | Terrain |
| -------      | ------- |
| Infantry     | Rivers ðŸžï¸ |
| Cavalry      | Plains ðŸŒ¾ |
| Supply wagon | Paved roads ðŸ›£ï¸ |

In this hypothetical game, one of your tasks as a designer is to decide on movement bonuses or penalties.

Here's one possible configuration:

| Unit type | Rivers  | Plains | Paved roads ðŸ›£ï¸ |
| --------  | ------ | ---------- | ---------- |
| Infantry     | 0   | +1 tile    | +2 tiles |
| Cavalry      | -1 tile   | +2 tiles   | +4 tiles |
| Supply wagon | -2 tiles   | 0          | +2 tiles |

Here's another one:

| Unit type | Rivers  | Plains | Paved roads |
| --------  | ------ | ---------- | ---------- |
| Infantry     | -1 tiles | 0         | +3 tiles |
| Cavalry      | -3 tiles | +3 tiles | +6 tiles |
| Supply wagon | -6 tiles | -3 tiles | +3 tiles  |

You can come up with justifications for these values, but ultimately the important thing is that the differentiations are **meaningful** to the user, just as in our earlier example of RPG battle. If the Supply Wagon is meant to be slow, is it enough to make it slightly slower than Infantry units? 

> **Instinctively, we know that differentiation also requires a floor and ceiling, a 0% to 100%**.

In our previous example, the length of the loop was computed purely through an attack action. By increasing the attack to a higher percentage of the total HP, attacking became more meaningful.

In the case of strategy games with movement, we can gain a sense of "playtime" through the size of a board and the number of players.

If the average unit movement value is 5 tiles, and the board is 15x15 tiles, then we can _feel_ that "spacing" unit buffs or debuffs by 1 (+1, +2, +3) might be meaningful, but if we change the board to 30x30, then assigning such low values is going to muddle the units; they'll all be roughly similar in movement.

<Image src={diff} alt='' />
tk add captions for the boards
_Cyan can move 5 tiles, and yellow can move up to 8, overlapping both pink (7) and purple (6) on the 15x15 board. A smaller board size means a greater percentage of movement per tile, which is lost if values are represented as whole numbers and aren't scaled through percentages or some other formula._

As we observed with the attack values, seeing those values as **percentages** of the total HP helped create more tension. In this example, the superiority or inferiority of one unit over another can be maintained by expressing the movement values as percentages against the **average board size**. To the user, they'll be whole numbers. In a spreadsheet, you can create formulas.

For our example, let's assume an average board size of **23x23**.

| Scale name | Formula | Value given board size of 23 |
| -------  | ------ | ------ |
| Best | +15% of average board size  | 4 |
| Great   | +9% of average board size  | 2 |
| Good    | +5% of average board size  | 1 |
| Neutral | 0 | 5 |
| Bad | -5% of average board size  | -1 |
| Terrible | -9% of average board size  | -2 |
| Worst | -15% of average board size  | -4 |

This table both normalizes the values by defining the level of (dis)advantages possible in the game, as well as the scaled movement buffs and debuffs.

### Basic normalization

tk - fix this section

There is another, more pragmatic problem: how do you scale up those numbers to create 30 unit types, or even 100 unit types without someone messing up by typing in an extra 0, or accidentally omitting the `-` sign in the case of debuffs?

By setting these variables or constants in one place, such as a constants file or sheet, you can reuse the values anywhere. Now, you've constrained the values to a certain set. This eliminates errors such as typing in `-8` or `-70` instead of `-7`. This process of separating raw values into their own table is basic normalization in game design.

(For those with a background in database design, this fulfills the 'no repeating values or groups' requirement of the first normal form (1NF) but doesn't necessarily satisfy 1NF by itself).

Additionally, if you need to rebalance the "Good" value, you only need to edit its definition in one file. Let's say that given 3 factions, each faction has 5 units that make use of a "small" buff, i.e. the "Good"-level buff. That's 15 units that can be instantly rebalanced by changing only one value.

## Summary

tk make this section nicer

- Start by figuring out what you want your user to do and how long that loop of gameplay should take to finish. 
  - Define a win or progression condition.
  - Define the steps (and choices) the user needs to make to win.
- Think of a core loop's length in terms of moves, whether turns or seconds.
- When setting stats, start with small numbers (1-50) when prototyping.
- Normalize your values.

## Image credits

- Let's Play Archive
- TCGPlayer
