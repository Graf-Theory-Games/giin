---
title: Fundamental stat setting and normalization in games
date: 2025-10-13
slug: 2025-10-13-devblog
featured: true
---

import cessna from '/src/assets/dv002-cessna.jpg';
import sliders from '/src/assets/dv002-sliders.jpg'
import square from '/src/assets/dv002-square.jpg'
import triace from '/src/assets/dv002-triace.jpg'

import { Image } from 'astro:assets';

<Image src={cessna} alt='By Olga Ernst - Own work, CC BY-SA 4.0' />
_The environment of a game is largely controlled by invisible sliders, dials, and levers._

How do we game designers know what values to use for our video games? Some games cap at level 99; others cap at level 20. Some games have 6 primary stats; other games have 8 or 10.

<Image src={square} alt='' />
_Square games in the 90s and early 2000s capped out at 255 for each whole number stat and 9999 for HP._

<Image src={triace} alt='' />
_tri-Ace games in the 90s and early 2000s capped out... wherever the hell they wanted to._
tk retake this screenshot

## Working forwards or backwards

One method to figure out values for stats, is to prototype an atom of gameplay, **working forward**. You'd start prototyping the core loop, possibly 2-3 other loops, giving yourself a deadline measured in weeks, not months. Those weeks are spent assembling a prototype with placeholder art and animation cues. In this scenario, you haven't figured out how big the game is going to be, nor how long it will take to get to the end, but you have to start somewhere.

Another method is to **work backwards**, or to begin with the end in mind. I've done this in professional environments where a period of experimentation, about 3 months for a vertical slice of a midcore mobile game, is baked into the costing and is part of a "real" timetable with milestones (deadlines) mapped to distributor and publisher events. You're not just doing a core loop prototype. With this method, the team is usually able to figure out the costing for the game and the amount of content based on results during this vertical slice and experimentation phase.

### Short detour on working backwards

Knowing the **amount** of content absolutely matters for stat adjustment — if you know your team can only make 60 unique creature designs in time for public beta, and you have an evolution mechanism, that works out to 30 monsters (each monster needs a unique "child" and "adult" design) thus the leveling formula has to account for that.

By working with a final deadline, we are also able to set a **cutoff line** that keeps scope creep at bay, among other things.

However, this method is not within this blog post's scope; today we'll be focusing on the "working forward" approach.

## The basics of working forward

The **prototype's playtime** (a core loop and maybe 2-3 other loops) and **your production time** are the two values you have to set based on your self-reflection and experience.

You may want to start conservatively until you have the experience to confidently say you can make a 15-minute demo. Remember that the tutorials of games can be 3 minutes or less and that a starting Pokemon battle against a Lv. 2 Rattata takes about 4 moves.

1. Figure out your core loop. You can do this by identifying repeating building blocks of gameplay. Your core loop will be among these, but there will be many other important loops.
1. Write the sequence of the core loop. What steps will the user do?
1. Compute the number of moves it takes to finish the core loop. Moves can either be **turn-based** or **time-based**. With back-of-the-napkin math, you can establish initial values before the prototype is finished, then feed the values to the prototype.
    - An example of a time-based move is a basic slash of a Paladin from Warcraft. You can expect a Paladin to slash every N seconds.
    - An example of a turn-based move is the Attack option in Suikoden II.
1. Prototype the core loop. 
1. Once the prototype has been finished with reasonable placeholder pauses for animation and cueing, test the values.

This blog post mostly explores step (3), but also touches on other steps broadly to help give an idea of how they affect stat-setting.

## Choosing an RPG game's core loop

RPGs have several major systems, including but not limited to:

- Exploration
- Battle
- Crafting

For the purposes of this blog post, let's take a look at a typical battle. The **win condition** of a battle is straightforward: it ends when the enemy party's hit points (HP) hits zero. To finish the core loop, you just have to keep decrementing the HP, typically through an attack. So when you prototype the battle, you can start with as little as:

- The characters
- An attack command
- Hit points
- Attack or damage points

### Controlling the size of a battle

Here are two hopefully uncontroversial statements:

- All other things being equal, a large map in StarCraft where the players are situated at opposite ends, will take longer to finish than a smaller map.
- All other things being equal, A 3vs3 Pokemon battle will be shorter than a full 6vs6.

Let's say we want an RPG player-versus-player game to be about 3-5 minutes long.

> The average completion of a core loop such as an RPG battle can be measured in the **average number of moves or turns** made to complete the loop.

Let's say that player A and player B use similar characters: 

| Character lineup | Atk | HP |
| -------          | ------ | ------ |
|  Abel            | 5    | 100 |
|  Benjamin        | 9    | 75  |
|  Cain            | 5    | 120 |
|  Daniel          | 7    | 90  |

**Total HP**: 385

**Total Atk**: 26

(tk add a bar here showing how miniscule 26 is against 385)

Dividing the **total HP** by the **total Atk** gives us an idea of how many turns you'd have to hit the opposite party.

It comes out to 14.81, or **15 turns of solid attacking** to knock out 4 characters. There are 2 players. So at a minimum, 30 turns.

Now we wanted our battle to last 3-5 minutes, or 180-300 seconds. Let's work backwards from those values:

```
180 seconds / 30 turns = 6 seconds per turn
300 seconds / 30 turns = 10 seconds per turn
```

6-10 seconds per turn is too little time to decide on the actions of 4 characters, so it's obvious that these numbers are unrealistic. The game will definitely drag on to more than 5 minutes, especially once we add other options aside from Attack.

It's evident that the HP is too high or the Atk is too low. Now that we know how to compute for the number of turns, let's create a limit of 6 turns by reducing the HP.

Let's get the total HP to end a party in 6 turns: 

```
(Total Atk) * (Ideal number of turns) = (New Total HP)
    26      *           6             = 156


(Previous Total HP) - (New Total HP) = (Reduction in HP)
        385         -     156           = 229
```


That comes to a 57HP reduction per character.

For now let's apply it evenly across the board:

| Character lineup | Atk | HP |
| -------          | ------ | ------ |
|  Abel            | 5    | 43 |
|  Benjamin        | 9    | 18  |
|  Cain            | 5    | 63 |
|  Daniel          | 7    | 33  |


Just from reading those numbers and their variance between characters you can already see the tension much more clearly — and we haven't even touched on other actions, such as Magic, or events such as Miss and Critical.

### Using "big" or "small" numbers

What meaning do numbers have if a game's core loop is measured in moves? The choice of big (`9,999`, `99,999`) or small (`99`) numbers boils down to utility and emotion.


tk ffviii 
To keep  battle relevant (or less of a total slaughter), enemies scale to the same level as the protagonists in FFVIII regardless of territory.

A chessboard has 64 squares, or 2^6. If we increase the chessboard size to 128, or 2^7, we know instinctively that we should scale the movement of knights, pawns, and kings.

Some things to ponder:

- If we scale the movement up, does that mean that the game would take more time to finish?
- Would scaling movement by ^2 retain the utility of the chess piece?

In other words, would scaling up be meaningful?

tk the answer is obviously no


Let's take a look at the case for small numbers.

#### Small numbers for PVP

Card and board games keep their numbers relatively small, at least until power creep takes over (see: Pokemon TCG). This is because players do the math themselves.

#### Big numbers for expressing game progression

## Our last big subject for today: normalization

Normalization in game design ensures that stats (health, speed, power, et cetera) are balanced and meaningful across the board.

## A strategy game example

Let's look at the ingredients of a turn-based strategy game.

Fire Emblem UI

Advance Wars 2 UI

Stratego

Based off of these images, we can identify the following components:

- A board composed of tiles
- These tiles represent terrain, and have bonuses or penalties depending on the unit traversing them.
- Units with movement and strength stats.

So let's set up some stats for a strategy game with two systems, **unit types** and **terrain**:

| Unit types   | Terrain |
| -------      | ------- |
| Infantry     | Rivers  |
| Cavalry      | Plains  |
| Supply wagon | Paved roads |

In this hypothetical game, one of your tasks as a designer is to decide on movement bonuses or penalties.

Here's one possible configuration:

| Unit type | Rivers  | Plains | Paved roads |
| --------  | ------ | ---------- | ---------- |
| Infantry     | 0   | +1 tile    | +2 tiles |
| Cavalry      | 0   | +2 tiles   | +4 tiles |
| Supply wagon | 0   | +0          | +2 tiles |

Here's another one:

| Unit type | Rivers  | Plains | Paved roads |
| --------  | ------ | ---------- | ---------- |
| Infantry     | -1 tiles | 0         | +3 tiles |
| Cavalry      | -3 tiles | +3 tiles | +6 tiles |
| Supply wagon | -6 tiles | -3 tiles | +3 tiles  |

You can come up with justifications for these values, but ultimately the important thing is that the differentiations are meaningful to the user, just as in our earlier example of RPG battle. If the Supply Wagon is meant to be slow, is it enough to make it slightly slower than Infantry units? What is "slightly slower" versus "too slow"? 

> **Instinctively, we know that differentiation requires a floor and ceiling**.

If the greatest possible value is 9 tiles, then instinctively we can _feel_ that "spacing" unit buffs or debuffs by 3 (3, 6, 9) might be meaningful, but if we change the highest value to 50, then assigning values such as 3, 6, 9 is obviously going to muddle the units.

tk It's all about percentages

Before we move on to _how to choose_ values, however, let's go over a more practical question: 

How do you scale up those numbers to create 30 unit types, or even 100 unit types without someone messing up by typing in an extra 0, or accidentally omitting the `-` sign?

## Applying basic normalization

Here's another way of viewing bonuses and penalties:

| Scale name | Value |
| -------  | ------ |
| Best | +7      |
| Great   | +5 |
| Good    | +3 |
| Neutral | 0 |
| Bad | -3 |
| Terrible | -5 |
| Worst | -7 |

By setting these variables or constants in one place, such as a constants file, you can reuse the values anywhere. Now, you've constrained the values to a certain set. This eliminates errors such as typing in `-8` or `-70` instead of `-7`. This process of separating raw values into their own table is basic normalization in game design.

(For those with a background in database design, this fulfills the 'no repeating values or groups' requirement of the first normal form (1NF) but doesn't necessarily satisfy 1NF by itself).

Additionally, if you need to rebalance the "Good" value, you only need to edit its definition in one file. Let's say that given 3 factions, each faction has 5 units that make use of a "small" buff, i.e. the "Good"-level buff. That's 15 units that can be instantly rebalanced by changing only one value.

### Applying ceilings and floors in stats

An earlier section of this post discussed the reason for choosing big or small numbers and how everything boils down to moves. The same can be applied to strategy games.

## Summary

- For turn based games, compute the length of a core loop by the number of moves or turns needed to finish the loop. The values themselves are **emotional**!
