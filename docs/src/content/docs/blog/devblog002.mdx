---
title: Basic stat setting and normalization in games
date: 2025-10-13
slug: 2025-10-13-devblog
featured: true
---

import playtime from '/src/assets/dv002-playtime.jpg';
import sliders from '/src/assets/dv002-sliders.jpg'
import square from '/src/assets/dv002-square.jpg'
import triace from '/src/assets/dv002-triace.png'
import party from '/src/assets/dv002-6v6.jpg'
import part from '/src/assets/dv002-part-of-whole.jpg'
import part2 from '/src/assets/dv002-part.jpg'
import ff8 from '/src/assets/dv002-ff8.jpg'
import no from '/src/assets/no.gif'
import phyrexian from '/src/assets/dv002-dreadnaught.jpg'
import iseria from '/src/assets/dv002-iseria.png'
import stones from '/src/assets/dv002-sacredstones.png'
import diff from '/src/assets/dv002-diff.jpg'
import wars from '/src/assets/dv002-advancewars.png'
import test from '/src/assets/memes/test-it-out.jpg'

import { Image } from 'astro:assets';

How do we game designers set values for our games? Some games cap at level 99; others cap at level 20. Some games have 6 primary stats; other games have 8 or 10.

<Image src={square} alt='Final Fantasy VIII max stats for Squall' width={256} layout='constrained' />

_Square games in the 90s and early 2000s capped out at **255** for each whole number stat and **9999** for HP._

<Image src={triace} alt='Valkyrie Profile stat window' />
_tri-Ace games in the 90s and early 2000s capped out... wherever the hell they wanted to._

## You will redo your stats

A game goes through innumerable changes and improvements during its development. Your tooling and mindset should expect that any stat, asset, or dialog will be reworked many, many times. That being said, that refinement should go in some _direction_. The goal of this post is to give a starting point when dowsing in the desert for that magical number.

Just because you know that the stats are going to be reworked doesn't mean that you can set random stats for your love interest's affection or your protagonist's speed. Early values do matter, because they can help strengthen your case for some mechanic or another. You still want to make these early values make sense.

> Are you working with a producer or manager who thinks that stats should be locked in at the start of a project? Someone who tries to follow a GDD religiously? This is one of the biggest pink flags to spot when working with others. Choose your team carefully!

## Setting your early stats

One method to figure out values for stats is to prototype a core loop of gameplay, **working forward**. You'd start prototyping the this loop, and maybe 2-3 other loops, then you'd feed the numbers you've computed on paper to that prototype.

I'd suggest a short deadline, not more than a month; this will force you into the habit of trimming any fat before figuring out the meat of your game. In this scenario, you haven't figured out how big the game is going to be, nor how long it will take to get to the end, but you have to start somewhere.

<Image src={test} alt='Test it out' />

Another method is to **work backwards**, or to begin with the end in mind, i.e. a release window. I've done this with projects where a period of experimentation, about 3 months for a vertical slice of a game, is baked into the costing and is part of a "real" timetable with milestones (deadlines) mapped to distributor and publisher events. **You're not just doing a core loop prototype**. With this method, the team is usually able to figure out the costing for the game and the amount of content based on results during this vertical slice and experimentation phase.

### A short note on working backwards

Knowing the **amount** of content absolutely matters for stat adjustment:

- If you know your team can only make 60 unique creature designs in time for public beta, and you have an evolution mechanism, that works out to 30 monsters (each monster needs a unique "child" and "adult" design) thus the leveling formula has to account for that.
- If you know that your game will have updates on the 1st week, 3rd week, first month, and so on, you might want to adjust stats to accommodate for that. Sometimes you might think to yourself, "Oh, our 999 max stat for a single-release game should be 9999 for a rolling-release game so that users feel like they've progressed more over the year of updates."

By working with a final deadline, we are also able to set a **cutoff line** that keeps scope creep at bay, among other things.

Today however we'll be focusing on the "working forward" approach, which is more friendly towards hobbyists and indies.

## The basics of working forward

Do you know much time it takes for you to **make** one minute of gameplay? Have you ever tried to time yourself when creating your game content?

<Image src={playtime} alt='Meme showing the time it takes to make the game content as opposed to its playtime' width={480} />

You may want to start conservatively (3 to 5 minute game demo) until you build confidence in your experience. Remember that the tutorials of games can be 3 minutes or less and that a starting Pokemon battle against a Lv. 2 Rattata takes about 4 moves‚Äîless than a minute.

Here are some steps to starting out in making a core loop demo or prototype:

1. Figure out your core loop. You can do this by identifying **repeating blocks of gameplay with clear win (progression) conditions**. Your core loop will be among these, but there will be many other important loops.
1. Write the sequence or flow chart of the core loop. What steps will the user do? What states can they wind up in?
1. Compute the number of moves it takes to finish the core loop. Moves can either be **turn-based** or **time-based**. With back-of-the-napkin math, you can establish initial values before the prototype is finished, then feed the values to the prototype.
    - An example of a time-based move is a basic slash of a Paladin from Warcraft. You can expect a Paladin to slash every N seconds.
    - An example of a turn-based move is the Attack option in Suikoden II.(*)
1. Prototype the core loop. 
1. Once the prototype has been finished with reasonable placeholder pauses for animation and cueing, test the values.

This blog post mostly explores **step (3)**.

_(*)Turn based moves still have to be converted to time values if you want to compute for your demo's playtime._

## Example 1: Choosing a role-playing game's core loop

RPGs have several major systems, including but not limited to:

- Exploration
- Battle
- Crafting

Any one of these could form the core loop of a game.

For the purposes of this blog post, let's take a look at a typical battle loop. The **win condition** of a battle is straightforward: it ends when the enemy party's hit points (HP) hits zero. To finish the core loop, you just have to keep reducing the HP, typically through an attack. So when you prototype the battle, you can start with as little as:

- The characters
- An attack command
- Hit points
- Attack or damage points

<Image src={party} alt='Suikoden 2 battle, 6v6' layout='constrained' />
_3-vs-3, 4-vs-4, and 6-vs-6 party sizes have to be set up in such a way that battle isn't tedious._

### Controlling the size of a gameplay loop through percentages

Here are two hopefully uncontroversial statements:

- All other things being equal, a large Starcraft map where the players are situated at opposite ends will take longer to finish than a smaller map.
- All other things being equal, A 6-vs-6 Pokemon battle will take longer than a 3-vs-3.

Let's say we want an RPG **player-versus-player** (PVP) game to be about **3-5 minutes** long.

> _The average completion of an RPG battle can be measured in the **number of moves or turns** made to complete the loop._

Thus we should convert the average number of turns into some time measurement.

Let's say that Player A and Player B use similar characters: 

| Character lineup | Atk | HP |
| -------          | ------ | ------ |
|  Abel            | 5    | 100 |
|  Benjamin        | 9    | 75  |
|  Cain            | 5    | 120 |
|  Daniel          | 7    | 90  |

**Total HP**: 385

**Total Atk**: 26

<Image src={part} alt='Bar showing how little total attack is opposed to total HP' />
_You can already see where this is going..._

Dividing the **total HP** by the **total Atk** gives us an idea of how many turns you'd have to hit the opposite party.

It comes out to 14.81, or **15 turns of solid attacking** to knock out 4 characters. There are 2 players, each taking turns hitting each other. So at a minimum, **29 turns** (first character to hit 15 turns knocks out the other, who was on their 14th turn: 15+14=29).

Now we wanted our battle to last 3-5 minutes, or 180-300 seconds. Let's work backwards from those values:

```
180 seconds / 29 turns = 6.21 seconds per turn
300 seconds / 29 turns = 10.34 seconds per turn
```

6-10 seconds per turn is too little time to decide on the actions of 4 characters, so it's obvious that these numbers are unrealistic. The game will definitely drag on to more than 5 minutes, especially once we add other options aside from Attack.

It's evident that the HP is too high or the Atk is too low. Now that we know how to compute for the number of turns, let's **set a limit of 5 turns per player** by reducing the HP.

Let's get the total HP to end a party in 5 turns: 

```
(Total Atk) * (Ideal number of turns) = (New Total HP)
    26      *           5             = 130

(Previous Total HP) - (New Total HP) = (Reduction in HP)
        385         -     130           = 255

(Reduction in HP) / (Number of Characters) = (Reduction per character)
        255         -     4           = 63.75
```


<Image src={part2} alt='Improved ratio of attack to HP' />
_Now it only takes us 9 turns to finish a fight._

That comes to a **63.75HP** reduction per character.

For now let's apply it evenly across the board, rounding down:

| Character lineup | Atk | Previous HP ‚Üí New HP |
| -------          | ------ | ------ |
|  Abel            | 5    | 100 ‚Üí **37** |
|  Benjamin        | 9    | 75 ‚Üí **12**  |
|  Cain            | 5    | 120 ‚Üí **57** |
|  Daniel          | 7    | 90 ‚Üí **27**  |

Just from reading those numbers and their variance between characters you can already see that there's more tension (and that Benjamin should probably be rebalanced)‚Äîand we haven't even touched on other actions, such as Magic, or events such as Miss and Critical.

## Using "big" or "small" numbers

What meaning do numbers have if a game's core loop is measured in percentages? The choice of big (`9,999`, `99,999`) or small (`99`) numbers boils down to utility and emotion.

<Image src={ff8} alt='Final Fantasy VIII battle screen' />
_To keep battle relevant, enemies scale to the same level as the protagonists in FFVIII regardless of location._

### Bigger isn't always meaningful  

A chessboard has 64 squares, or 2^6. If we increase the chessboard size to 128, or 2^7, we know instinctively that we should scale the movement of knights, pawns, and kings (bishops, queens, and towers can move any number of tiles, so they stay the same).

Some things to ponder:

- If we scale the movement up, does that mean that the game would take more time to finish?
- Would scaling movement retain the utility of the chess piece?

In other words, would scaling up be meaningful?

<Image src={no} alt='Meme saying no' width={256} layout='constrained' />

Let's take a look at the case for small numbers.

#### Small numbers for PVP and prototyping

<Image src={phyrexian} alt='Phyrexian Dreadnought card from Magic the Gathering' width={256} layout='constrained' />
_Many card and board games keep their numbers relatively small._

Numbers are kept "small" because players do the math themselves. Baldur's Gate, which mostly follows 5th Edition Dungeons and Dragons (DnD) mechanics, caps out at level 20. The numbers of a standard polyhedral dice set don't go over 99. This is because DnD was originally played on paper and pencil and thus the game's number scale follows suit.

#### Big numbers for expressing game progression, PvE games

Big numbers tug at our emotions. They give users a sense of progression. After all, the hours you spend on a game only go up, so your stats should too. You start with 50 HP and ten hours in it's hit 7,000. That gives you a sense of accomplishment.

Mind you, game designers have the option to lessen the amount of experience points doled out; some RPGs require that you only have 100 EXP to level up for each level. But where's the fun in that?


<Image src={iseria} alt='Iseria Queen from Valkyrie Profile' />
_The Iseria Queen from Valkyrie Profile is the last secret optional boss of the game and has... **2,300,000 HP**._

## Our last topic for today: normalization

Normalization in game design ensures that stats (health, speed, power, etc.) are balanced and meaningful across the board.

### Example 2: Movement in a strategy game

Let's look at the ingredients of a turn-based strategy game.

<Image src={stones} alt='Fire Emblem: The Sacred Stones battle screen showing movement range' />
_**Fire Emblem: The Sacred Stones** shows possible movement range in blue and attack range in red._

<Image src={wars} alt='Advance Wars battle screen showing movement range' />
_In **Advance Wars**, tanks can't occupy mountains and their movement is reduced by 1 tile on plains._

Based off of these images, we can identify the following components:

- A **board** composed of tiles.
- These **tiles** represent **terrain**, and have bonuses or penalties depending on the unit traversing them.
- **Units** the player controls, with movement and strength stats.

So let's set up some stats for a strategy game with two systems, **unit types** and **terrain**:

| Unit types      | Terrain        |
| -------         | -------        |
| Infantry ü§∫     | Rivers üèûÔ∏è      |
| Cavalry üêé      | Plains üåæ      |
| Supply wagon üêÇ | Paved roads üõ£Ô∏è |

In this hypothetical game, one of your tasks as a designer is to decide on movement bonuses or penalties.

Here's one possible configuration:

**Base Average unit movement value: ** 5 tiles

Without applying bonuses or penalties, the average unit will move 5 tiles. This number is chosen based on it being small and easy to compute around, but is ultimately chosen somewhat arbitrarily.

| Unit type      | Rivers üèûÔ∏è | Plains üåæ  | Paved roads üõ£Ô∏è |
| --------       | ------    | ---------- | ----------     |
| Infantry ü§∫    | 0         | +1 tile    | +2 tiles       |
| Cavalry üêé     | -1 tile   | +2 tiles   | +4 tiles       |
| Supply wagon üêÇ| -2 tiles  | 0          | +2 tiles       |

Here's another one:

| Unit type       | Rivers üèûÔ∏è | Plains üåæ  | Paved roads üõ£Ô∏è |
| --------        | ------    | ---------- | ----------     |
| Infantry ü§∫     | -1 tiles  | 0          | +3 tiles       |
| Cavalry üêé      | -3 tiles  | +3 tiles   | +5 tiles       |
| Supply wagon üêÇ | -6 tiles  | -3 tiles   | +3 tiles       |

You can come up with justifications for these values, but ultimately the important thing is that the differentiations are **meaningful** to the user, just as in our earlier example of RPG battle. If the Supply Wagon is meant to be slow, is it enough to make it slightly slower than Infantry units?

Another problem that pops up when creating stats for many units is the uniqueness of the values. In our second configuration, we have **Infantry** with a `-1` value and **Cavalry** with a `+5` buff, whereas the other units use `6` and `3`. We know at the back of our mind that we shouldn't have "too many unique values" so we need to standardize or normalize this in some way.

> **Instinctively, we know that differentiation also requires a floor and ceiling, a 0% to 100%**.

In our previous example, the length of the loop was computed purely through an attack action. By increasing the attack to a higher percentage of the total HP, attacking became more meaningful.

In the case of strategy games with movement, we can gain a sense of "playtime" through the size of a board and the number of players.

If the average unit movement value is 5 tiles, and the board is 15x15 tiles, then we can _feel_ that "spacing" unit buffs or debuffs by 1 (+1, +2, +3) might be meaningful, but if we change the board to 30x30, then assigning such low values is going to muddle the units; they'll all be roughly similar in movement.

<Image src={diff} alt='Different colored tiles to represent different max movement ranges' />
_Cyan represents a 5-tile movement range. Yellow covers 8 tiles, overlapping both pink (7) and purple (6) on the 15x15 board. On a larger board, they all appear to move similarly. A smaller board size means a greater percentage of movement per tile, which is lost if values are represented as whole numbers and aren't scaled through percentages or some other formula._

As we observed with the attack values, seeing those values as **percentages** of the total HP helped create more tension. In this example, the superiority or inferiority of one unit over another can be maintained by expressing the movement values as percentages against the **average board size**. To the user, they'll be whole numbers. In a spreadsheet, you can create formulas.

For our example, let's assume an average board size of **23x23**. Let's also define the **scale levels** so that we don't have too many unique numbers for our stats, as we saw with Cavalry and Infantry earlier.

| Scale level | Formula | Value given board size of 23 |
| -------  | ------ | ------ |
| Best | +15% of average board size  | +4 |
| Great   | +9% of average board size  | +2 |
| Good    | +5% of average board size  | +1 |
| Neutral | 0 | 5 (Base movement value)  |
| Bad | -5% of average board size  | -1 |
| Terrible | -9% of average board size  | -2 |
| Worst | -15% of average board size  | -4 |

This table both normalizes the values by defining the level of (dis)advantages possible in the game, as well as the scaled movement buffs and debuffs. Let's apply it in the next section.

### Basic normalization

Now that we have defined scale levels ("Best", "Terrible", "Good" and so on), we've limited the scope to a subset of numbers. That's the rough idea of **statistical** normalization: ordering numbers on a common scale. 

| Unit type       | Rivers üèûÔ∏è | Plains üåæ  | Paved roads üõ£Ô∏è |
| --------        | ------    | ---------- | ----------     |
| Infantry ü§∫     | Bad  | Neutral         | Great       |
| Cavalry üêé      | Terrible  | Great   | Best       |
| Supply wagon üêÇ | Worst  | Bad   | Great       |

| Unit type       | Rivers üèûÔ∏è | Plains üåæ  | Paved roads üõ£Ô∏è |
| --------        | ------    | ---------- | ----------     |
| Infantry ü§∫     | 4 | 5         | 7       |
| Cavalry üêé      | 3  | 7   | 9       |
| Supply wagon üêÇ | 1  | 4   | 7       |

You'll notice that **Good** didn't appear. One of the side effects of normalization is the ease by which variety or a lack thereof can be easier to spot.

- Perhaps other units, such as **Artillery** or a **Vanguard** might provide movement variety.
- Perhaps **Cavalry** units are fleet, but actually terrible at dealing damage. 

Normalization also reduces the chances of making simple typing errors when you have 100+ units.

You can set these variables or constants in one place, such as a constants file or sheet, and reuse the values anywhere. Now, you've constrained the values to a certain set. This eliminates errors such as typing in `-8` or `-70` instead of `-7`. This process of separating raw values into their own table with scale levels is basic normalization in game design.

(For those with a background in database design, this fulfills the 'no repeating values or groups' requirement of the first normal form (1NF) for **database normalization** but doesn't necessarily satisfy 1NF by itself).

Additionally, if you need to rebalance the "Good" value, you only need to edit its definition in one file. Let's say that given 3 factions, each faction has 5 units that make use of a "small" buff, i.e. the "Good"-level buff. That's 15 units that can be instantly rebalanced by changing only one value.

## Summary

- Start by figuring out what you want your user to do and how long that loop of gameplay should take to finish. 
  - Define a win or progression condition.
  - Define the steps (and choices) the user needs to make to win.
- Think of a core loop's length in terms of moves, whether turns or seconds.
- When setting stats, start with small numbers (1-50) when prototyping.
- Normalize your values, and for database admins, that doesn't mean having to normalize to 3NF.

## Image credits

- [Let's Play Archive](https://lparchive.org/)
- [TCGPlayer](https://www.tcgplayer.com/)
