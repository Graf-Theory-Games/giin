---
title: GIIN begins
date: 2025-08-29
featured: true
---
import demoLog1 from '/src/assets/giin-log3.mp4';
import giinLogo from '/src/assets/giin-logo-temp.png';

<img src={giinLogo} />

<picture><source srcset={giinLogo} /></picture>

![GIIN logo](/giin-logo-temp.png)

Generic Incremental Interactive eNgine (GIIN) is a small engine for building menu-based games. It currently supports basic visual novel mechanics similar to [Twine](www.twinery.org), and is in development towards eventually supporting incremental and adventure game mechanics. It is built on ReactJS and is in early development.

## Beginnings

GIIN began life sometime in July 2025 as a Vite-TypeScript-React template app. The initial goal was to create an engine that could make incremental or visual novel games. These genres felt suitable for a single developer to relearn how to make games.

Here's a a demo showing basic visual novel features - dialog, a portrait, and interactions through user choices:

<video width="480" height="360" controls><source src={demoLog1} type="video/mp4" /></video>
_**Figure**. Choices, branching dialog, and portrait support._

Previously, I'd shipped a few adventure games using a proprietary game engine made by C++ programmers; I was a productive designer on that engine and wanted to recreate the snappiness of making games with it.
 
It used MS Excel to manage variables in the game, which made data normalization and bulk updates trivial. While it is obvious today to use Google Sheets to export to JSON or CSV, back in 2010 using Excel to export to `.lua` data files was new to me. (I'd simply added objects manually to a MySQL database before that.)
 
To play to my strengths and to learn new skills, I decided that GIIN would use the following:

- **React and TypeScript** for the frontend and logic: I'd coded in React/TypeScript on and off on the job, but always in bits and pieces I decided it was time for me to learn it.
- An **xlwings** Python exporter from MS Excel for the data export: Previously I'd used xlwings to create prototypes and I was (and am) more comfortable with Excel data validation, macros, and shortcuts.

### The first milestone - a data exporter and editor

My first milestone was to be able to quickly export data from MS Excel into the game.

Given something like:

tk

A corresponding table in Excel would look like this:

tk

And in the game UI:

tk

#### Data export pipeline as proof-of-concept milestone

![DESCRIPTION-tk](/public/memes/no-capes.gif)

_No hardcoded data!_

I wanted a simple **data export pipeline as my first milestone** for the following reasons:

##### Pipeline is everything

A good pipeline supported by good tools means that mistakes can be corrected quickly, that data (content) can be easily placed into the game, and people can check their own work.

##### It's a proof-of-concept... to myself

Making a data exporter is tells me that I have sufficient programming chops, or learning chops, to pull off a simple menu-based game. It's proof that I can make a basic game pipeline from end-to-end.

##### It enforces data and logic separation early

Hardcoded data is difficult to find and refactor the longer it stays in the engine.

##### It makes prototyping quick

tk

I also wanted MS Excel as my primary data editor.

- It's easy to update content in bulk.
- You can validate data in different ways.
- You can concatenate from other cells to set up paths and other formulaic values. 
- Having data in a tabular format makes it easy to normalize the data.

#### The method

I planned to keep the scope for the exporter as small as I could. I asked myself, _what's the smallest unit of gameplay I can express through data?_ Between incremental mechanics and visual novel mechanics, the easier system is the visual novel, so that's what I decided to work on.

A visual novel can be as simple as the player meeting a love interest, talking to them, and increasing the affection level through certain choices. Thus the bare minimum goal was to create:

- A **love interest** with an **affection** stat.
- **Dialog** that ends in a question for the player to interact with.
- A set of **choices** with different **stat effects**, some raising the love interest's affection stat more than others.

To make the whole pipeline, I wrote the code in this order:

1. **The initial game UI (or frontend) in React**. The game at this point used hardcoded, dummy data stored as variables.
2. **The game objects, such as the concept of a love interest, a stat, a choice**. I used object-oriented programming for these. At this stage I wrote some classes, then their instances were imported into the game UI. The instances were still in a sense hardcoded, in that they were still difficult to create or update in bulk.
3. **The exporter in Excel**. 
4. **The game UI, refactored**. I went back to the game UI and removed the hardcoded variables.

The pipeline came to life in that order with some backtracking when I needed to correct some design decisions.

